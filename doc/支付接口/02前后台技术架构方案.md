# 02前后台技术架构方案

## 基于 Nano Banana AI 的技术架构分析与设计

### 1. 前端技术架构

#### 1.1 技术栈选择
```javascript
// 核心框架
- React 18+ / Vue 3+ / Next.js 13+
- TypeScript 5+
- Tailwind CSS / Ant Design / Material-UI

// 状态管理
- Redux Toolkit / Zustand / Pinia
- React Query / SWR (数据获取)

// 支付集成
- PayPal JavaScript SDK
- Stripe Elements (备选)

// 国际化
- react-i18next / vue-i18n
- 多语言支持（中文、英文等）
```

#### 1.2 前端目录结构
```
src/
├── components/           # 通用组件
│   ├── ui/              # 基础UI组件
│   ├── forms/           # 表单组件
│   ├── modals/          # 弹窗组件
│   └── payment/         # 支付相关组件
├── pages/               # 页面组件
│   ├── auth/            # 认证页面
│   ├── dashboard/       # 用户面板
│   ├── pricing/         # 定价页面
│   └── payment/         # 支付页面
├── hooks/               # 自定义Hooks
│   ├── useAuth.js       # 认证Hook
│   ├── useSubscription.js # 订阅Hook
│   └── usePayment.js    # 支付Hook
├── services/            # API服务
│   ├── auth.js          # 认证API
│   ├── subscription.js  # 订阅API
│   ├── payment.js       # 支付API
│   └── credits.js       # 积分API
├── store/               # 状态管理
│   ├── auth.js          # 认证状态
│   ├── user.js          # 用户状态
│   └── subscription.js  # 订阅状态
├── utils/               # 工具函数
│   ├── api.js           # API配置
│   ├── constants.js     # 常量定义
│   └── helpers.js       # 辅助函数
└── styles/              # 样式文件
    ├── globals.css      # 全局样式
    └── components.css   # 组件样式
```

#### 1.3 核心前端组件设计

##### 1.3.1 定价页面组件
```jsx
// components/pricing/PricingCard.jsx
import React from 'react';
import { useTranslation } from 'react-i18next';
import { useAuth } from '@/hooks/useAuth';
import { usePayment } from '@/hooks/usePayment';

const PricingCard = ({ plan, isPopular = false }) => {
  const { t } = useTranslation();
  const { user } = useAuth();
  const { initiatePayment, loading } = usePayment();

  const handleSubscribe = async () => {
    if (!user) {
      // 跳转到登录页面
      return;
    }
    
    await initiatePayment({
      planId: plan.id,
      planCode: plan.plan_code,
      amount: plan.price_monthly,
      currency: 'USD'
    });
  };

  return (
    <div className={`pricing-card ${isPopular ? 'popular' : ''}`}>
      <div className="card-header">
        <h3>{t(`plans.${plan.plan_code}.name`)}</h3>
        <div className="price">
          <span className="currency">$</span>
          <span className="amount">{plan.price_monthly}</span>
          <span className="period">/{t('common.month')}</span>
        </div>
      </div>
      
      <div className="card-body">
        <div className="credits">
          <span className="credits-amount">{plan.credits_monthly}</span>
          <span className="credits-label">{t('common.credits')}</span>
        </div>
        
        <ul className="features-list">
          {Object.entries(plan.features).map(([key, value]) => (
            <li key={key} className={value ? 'included' : 'not-included'}>
              {t(`features.${key}`)}
            </li>
          ))}
        </ul>
      </div>
      
      <div className="card-footer">
        <button 
          className="subscribe-btn"
          onClick={handleSubscribe}
          disabled={loading}
        >
          {loading ? t('common.loading') : t('common.subscribe')}
        </button>
      </div>
    </div>
  );
};

export default PricingCard;
```

##### 1.3.2 支付组件
```jsx
// components/payment/PayPalButton.jsx
import React, { useEffect, useRef } from 'react';
import { usePayment } from '@/hooks/usePayment';

const PayPalButton = ({ order, onSuccess, onError, onCancel }) => {
  const paypalRef = useRef();
  const { createPayPalOrder, capturePayPalOrder } = usePayment();

  useEffect(() => {
    if (window.paypal) {
      window.paypal.Buttons({
        createOrder: async () => {
          try {
            const orderData = await createPayPalOrder(order);
            return orderData.id;
          } catch (error) {
            onError(error);
          }
        },
        onApprove: async (data) => {
          try {
            const result = await capturePayPalOrder(data.orderID);
            onSuccess(result);
          } catch (error) {
            onError(error);
          }
        },
        onCancel: onCancel,
        onError: onError,
        style: {
          layout: 'vertical',
          color: 'blue',
          shape: 'rect',
          label: 'paypal'
        }
      }).render(paypalRef.current);
    }
  }, [order]);

  return <div ref={paypalRef}></div>;
};

export default PayPalButton;
```

##### 1.3.3 用户面板组件
```jsx
// components/dashboard/SubscriptionStatus.jsx
import React from 'react';
import { useTranslation } from 'react-i18next';
import { useSubscription } from '@/hooks/useSubscription';

const SubscriptionStatus = () => {
  const { t } = useTranslation();
  const { subscription, credits, loading } = useSubscription();

  if (loading) return <div>Loading...</div>;

  return (
    <div className="subscription-status">
      <div className="current-plan">
        <h3>{t('dashboard.currentPlan')}</h3>
        <div className="plan-info">
          <span className="plan-name">{subscription?.plan_name}</span>
          <span className="plan-status">{subscription?.status}</span>
        </div>
        {subscription?.end_date && (
          <div className="expiry-date">
            {t('dashboard.expiresOn', { date: subscription.end_date })}
          </div>
        )}
      </div>
      
      <div className="credits-info">
        <h3>{t('dashboard.credits')}</h3>
        <div className="credits-display">
          <div className="available-credits">
            <span className="amount">{credits?.available_credits || 0}</span>
            <span className="label">{t('dashboard.available')}</span>
          </div>
          <div className="monthly-quota">
            <span className="amount">{credits?.monthly_quota || 0}</span>
            <span className="label">{t('dashboard.monthlyQuota')}</span>
          </div>
        </div>
        <div className="usage-progress">
          <div className="progress-bar">
            <div 
              className="progress-fill"
              style={{ 
                width: `${(credits?.used_credits / credits?.monthly_quota) * 100}%` 
              }}
            />
          </div>
          <span className="usage-text">
            {credits?.used_credits} / {credits?.monthly_quota} {t('common.used')}
          </span>
        </div>
      </div>
    </div>
  );
};

export default SubscriptionStatus;
```

### 2. 后端技术架构

#### 2.1 技术栈选择
```python
# 核心框架
- FastAPI / Django REST Framework / Express.js
- Python 3.11+ / Node.js 18+
- PostgreSQL 15+ / Redis 7+

# 认证授权
- JWT Token
- OAuth 2.0 (Google, Facebook登录)
- bcrypt (密码加密)

# 支付集成
- PayPal REST API
- Stripe API (备选)
- 支付宝/微信支付 (国内市场)

# 任务队列
- Celery + Redis / Bull Queue
- 定时任务处理

# 监控日志
- Sentry (错误监控)
- Prometheus + Grafana (性能监控)
- ELK Stack (日志分析)
```

#### 2.2 后端目录结构
```
backend/
├── app/
│   ├── api/                 # API路由
│   │   ├── v1/
│   │   │   ├── auth.py      # 认证相关
│   │   │   ├── users.py     # 用户管理
│   │   │   ├── subscriptions.py # 订阅管理
│   │   │   ├── payments.py  # 支付处理
│   │   │   └── credits.py   # 积分管理
│   ├── core/                # 核心配置
│   │   ├── config.py        # 配置文件
│   │   ├── database.py      # 数据库连接
│   │   ├── security.py      # 安全配置
│   │   └── dependencies.py  # 依赖注入
│   ├── models/              # 数据模型
│   │   ├── user.py          # 用户模型
│   │   ├── subscription.py  # 订阅模型
│   │   ├── payment.py       # 支付模型
│   │   └── credit.py        # 积分模型
│   ├── schemas/             # Pydantic模式
│   │   ├── user.py          # 用户模式
│   │   ├── subscription.py  # 订阅模式
│   │   └── payment.py       # 支付模式
│   ├── services/            # 业务逻辑
│   │   ├── auth_service.py  # 认证服务
│   │   ├── subscription_service.py # 订阅服务
│   │   ├── payment_service.py # 支付服务
│   │   └── credit_service.py # 积分服务
│   ├── utils/               # 工具函数
│   │   ├── email.py         # 邮件发送
│   │   ├── validators.py    # 验证器
│   │   └── helpers.py       # 辅助函数
│   └── tasks/               # 异步任务
│       ├── payment_tasks.py # 支付相关任务
│       └── subscription_tasks.py # 订阅相关任务
├── migrations/              # 数据库迁移
├── tests/                   # 测试文件
├── requirements.txt         # 依赖包
└── main.py                  # 应用入口
```

#### 2.3 核心后端服务设计

##### 2.3.1 认证服务
```python
# services/auth_service.py
from datetime import datetime, timedelta
from typing import Optional
import jwt
import bcrypt
from sqlalchemy.orm import Session
from app.models.user import User
from app.core.config import settings

class AuthService:
    def __init__(self, db: Session):
        self.db = db
    
    def authenticate_user(self, email: str, password: str) -> Optional[User]:
        """用户认证"""
        user = self.db.query(User).filter(User.email == email).first()
        if not user or not self.verify_password(password, user.password_hash):
            return None
        
        # 更新登录信息
        user.last_login_at = datetime.utcnow()
        user.login_count += 1
        self.db.commit()
        
        return user
    
    def create_access_token(self, user_id: int) -> str:
        """创建访问令牌"""
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        payload = {
            "user_id": user_id,
            "exp": expire,
            "type": "access"
        }
        return jwt.encode(payload, settings.SECRET_KEY, algorithm="HS256")
    
    def create_refresh_token(self, user_id: int) -> str:
        """创建刷新令牌"""
        expire = datetime.utcnow() + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
        payload = {
            "user_id": user_id,
            "exp": expire,
            "type": "refresh"
        }
        return jwt.encode(payload, settings.SECRET_KEY, algorithm="HS256")
    
    @staticmethod
    def hash_password(password: str) -> str:
        """密码哈希"""
        return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    
    @staticmethod
    def verify_password(password: str, hashed: str) -> bool:
        """验证密码"""
        return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))
```

##### 2.3.2 支付服务
```python
# services/payment_service.py
import paypalrestsdk
from typing import Dict, Any
from sqlalchemy.orm import Session
from app.models.payment import PaymentOrder
from app.models.subscription import UserSubscription
from app.core.config import settings

class PaymentService:
    def __init__(self, db: Session):
        self.db = db
        self.setup_paypal()
    
    def setup_paypal(self):
        """配置PayPal SDK"""
        paypalrestsdk.configure({
            "mode": settings.PAYPAL_MODE,  # sandbox or live
            "client_id": settings.PAYPAL_CLIENT_ID,
            "client_secret": settings.PAYPAL_CLIENT_SECRET
        })
    
    def create_paypal_order(self, user_id: int, plan_id: int, amount: float) -> Dict[str, Any]:
        """创建PayPal订单"""
        # 创建本地订单记录
        order = PaymentOrder(
            user_id=user_id,
            plan_id=plan_id,
            amount=amount,
            currency="USD",
            payment_method="paypal",
            payment_status="pending"
        )
        self.db.add(order)
        self.db.commit()
        
        # 创建PayPal支付
        payment = paypalrestsdk.Payment({
            "intent": "sale",
            "payer": {"payment_method": "paypal"},
            "redirect_urls": {
                "return_url": f"{settings.FRONTEND_URL}/payment/success",
                "cancel_url": f"{settings.FRONTEND_URL}/payment/cancel"
            },
            "transactions": [{
                "item_list": {
                    "items": [{
                        "name": f"Subscription Plan",
                        "sku": f"plan_{plan_id}",
                        "price": str(amount),
                        "currency": "USD",
                        "quantity": 1
                    }]
                },
                "amount": {
                    "total": str(amount),
                    "currency": "USD"
                },
                "description": "Subscription payment"
            }]
        })
        
        if payment.create():
            # 更新订单信息
            order.external_order_id = payment.id
            self.db.commit()
            
            # 获取支付链接
            for link in payment.links:
                if link.rel == "approval_url":
                    return {
                        "order_id": order.id,
                        "paypal_order_id": payment.id,
                        "approval_url": link.href
                    }
        else:
            order.payment_status = "failed"
            self.db.commit()
            raise Exception(f"PayPal payment creation failed: {payment.error}")
    
    def execute_paypal_payment(self, payment_id: str, payer_id: str) -> Dict[str, Any]:
        """执行PayPal支付"""
        payment = paypalrestsdk.Payment.find(payment_id)
        
        if payment.execute({"payer_id": payer_id}):
            # 更新订单状态
            order = self.db.query(PaymentOrder).filter(
                PaymentOrder.external_order_id == payment_id
            ).first()
            
            if order:
                order.payment_status = "completed"
                order.external_payment_id = payer_id
                order.paid_at = datetime.utcnow()
                order.payment_data = payment.to_dict()
                self.db.commit()
                
                # 激活订阅
                self.activate_subscription(order.user_id, order.plan_id)
                
                return {
                    "status": "success",
                    "order_id": order.id,
                    "payment_id": payment_id
                }
        else:
            raise Exception(f"PayPal payment execution failed: {payment.error}")
    
    def activate_subscription(self, user_id: int, plan_id: int):
        """激活用户订阅"""
        from app.services.subscription_service import SubscriptionService
        subscription_service = SubscriptionService(self.db)
        subscription_service.create_subscription(user_id, plan_id)
```

##### 2.3.3 订阅服务
```python
# services/subscription_service.py
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from app.models.subscription import UserSubscription, SubscriptionPlan
from app.models.credit import UserCredit, CreditTransaction

class SubscriptionService:
    def __init__(self, db: Session):
        self.db = db
    
    def create_subscription(self, user_id: int, plan_id: int, subscription_type: str = "monthly"):
        """创建用户订阅"""
        plan = self.db.query(SubscriptionPlan).filter(SubscriptionPlan.id == plan_id).first()
        if not plan:
            raise ValueError("Invalid plan")
        
        # 检查是否有活跃订阅
        existing = self.db.query(UserSubscription).filter(
            UserSubscription.user_id == user_id,
            UserSubscription.status == "active"
        ).first()
        
        if existing:
            existing.status = "cancelled"
            existing.cancelled_at = datetime.utcnow()
        
        # 计算订阅期限
        start_date = datetime.utcnow()
        if subscription_type == "yearly":
            end_date = start_date + timedelta(days=365)
        elif subscription_type == "lifetime":
            end_date = None
        else:  # monthly
            end_date = start_date + timedelta(days=30)
        
        # 创建新订阅
        subscription = UserSubscription(
            user_id=user_id,
            plan_id=plan_id,
            subscription_type=subscription_type,
            status="active",
            start_date=start_date,
            end_date=end_date
        )
        self.db.add(subscription)
        
        # 更新用户积分
        self.update_user_credits(user_id, plan.credits_monthly)
        
        self.db.commit()
        return subscription
    
    def update_user_credits(self, user_id: int, monthly_credits: int):
        """更新用户积分"""
        user_credit = self.db.query(UserCredit).filter(UserCredit.user_id == user_id).first()
        
        if not user_credit:
            user_credit = UserCredit(
                user_id=user_id,
                total_credits=monthly_credits,
                available_credits=monthly_credits,
                monthly_quota=monthly_credits,
                quota_reset_date=datetime.utcnow() + timedelta(days=30)
            )
            self.db.add(user_credit)
        else:
            user_credit.total_credits += monthly_credits
            user_credit.available_credits += monthly_credits
            user_credit.monthly_quota = monthly_credits
            user_credit.quota_reset_date = datetime.utcnow() + timedelta(days=30)
        
        # 记录积分交易
        transaction = CreditTransaction(
            user_id=user_id,
            transaction_type="earn",
            amount=monthly_credits,
            balance_after=user_credit.available_credits,
            source="subscription",
            description="Monthly subscription credits"
        )
        self.db.add(transaction)
    
    def consume_credits(self, user_id: int, amount: int, feature_type: str) -> bool:
        """消费积分"""
        user_credit = self.db.query(UserCredit).filter(UserCredit.user_id == user_id).first()
        
        if not user_credit or user_credit.available_credits < amount:
            return False
        
        user_credit.used_credits += amount
        user_credit.available_credits -= amount
        
        # 记录消费交易
        transaction = CreditTransaction(
            user_id=user_id,
            transaction_type="spend",
            amount=-amount,
            balance_after=user_credit.available_credits,
            source="usage",
            description=f"Credits consumed for {feature_type}"
        )
        self.db.add(transaction)
        self.db.commit()
        
        return True
```

### 3. API接口设计

#### 3.1 认证相关API
```python
# api/v1/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.core.dependencies import get_db
from app.services.auth_service import AuthService
from app.schemas.user import UserLogin, UserRegister, Token

router = APIRouter(prefix="/auth", tags=["authentication"])

@router.post("/login", response_model=Token)
async def login(user_data: UserLogin, db: Session = Depends(get_db)):
    auth_service = AuthService(db)
    user = auth_service.authenticate_user(user_data.email, user_data.password)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials"
        )
    
    access_token = auth_service.create_access_token(user.id)
    refresh_token = auth_service.create_refresh_token(user.id)
    
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer"
    }

@router.post("/register", response_model=Token)
async def register(user_data: UserRegister, db: Session = Depends(get_db)):
    auth_service = AuthService(db)
    # 注册逻辑实现
    pass
```

#### 3.2 支付相关API
```python
# api/v1/payments.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.core.dependencies import get_db, get_current_user
from app.services.payment_service import PaymentService
from app.schemas.payment import CreatePaymentOrder, PaymentCallback

router = APIRouter(prefix="/payments", tags=["payments"])

@router.post("/create-order")
async def create_payment_order(
    order_data: CreatePaymentOrder,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    payment_service = PaymentService(db)
    result = payment_service.create_paypal_order(
        user_id=current_user.id,
        plan_id=order_data.plan_id,
        amount=order_data.amount
    )
    return result

@router.post("/paypal/callback")
async def paypal_callback(
    callback_data: PaymentCallback,
    db: Session = Depends(get_db)
):
    payment_service = PaymentService(db)
    result = payment_service.execute_paypal_payment(
        payment_id=callback_data.payment_id,
        payer_id=callback_data.payer_id
    )
    return result
```

### 4. 部署和运维

#### 4.1 Docker容器化
```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

#### 4.2 Docker Compose配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/dbname
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=dbname
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
```

#### 4.3 Nginx配置
```nginx
# nginx.conf
server {
    listen 80;
    server_name your-domain.com;

    location /api/ {
        proxy_pass http://backend:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    location / {
        proxy_pass http://frontend:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

### 5. 安全考虑

#### 5.1 API安全
- JWT Token认证
- API限流 (Rate Limiting)
- CORS配置
- 输入验证和清理
- SQL注入防护

#### 5.2 支付安全
- HTTPS强制
- PayPal Webhook验证
- 订单状态验证
- 重复支付检测
- 敏感数据加密

### 6. 监控和日志

#### 6.1 应用监控
- 健康检查端点
- 性能指标收集
- 错误率监控
- 响应时间监控

#### 6.2 业务监控
- 支付成功率
- 订阅转化率
- 用户活跃度
- 积分使用情况

这个技术架构方案提供了完整的前后端实现方案，包括数据库设计、API设计、支付集成、安全考虑和部署方案。
